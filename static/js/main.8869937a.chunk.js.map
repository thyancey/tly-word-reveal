{"version":3,"sources":["themes/index.js","containers/main/wordbox.js","containers/utils/index.js","containers/main/index.js","serviceWorker.js","index.js"],"names":["getColor","colorId","store","color","breakpoints","black","grey","grey_light","white","blue","green","yellow","red","purple","shadow","z1","z2","z3","value","headerHeight","menuWidth","mixins","mobile_tiny","mobile_medium","mobile_large","tablet","desktop","alphabet","S","WordBox","styled","div","Letter","li","p","isSecret","css","makeGrid","cols","rows","foundSecrets","newGrid","wb","document","querySelector","dims","clientWidth","clientHeight","xStep","yStep","secretStuff","secretWord","startRow","Math","floor","length","col","row","startCol","secret","c","push","gridIdx","rIdx","cIdx","text","getSecretIndicies","yPos","r","didFindSecret","letter","existingSecret","find","s","random","randomSecretPick","x","y","useState","count","setCount","delay","grid","setGrid","setFoundSecrets","width","undefined","height","windowSize","setWindowSize","useEffect","handleResize","window","innerWidth","innerHeight","addEventListener","removeEventListener","useWindowSize","callback","savedCallback","useRef","current","id","setInterval","clearInterval","useInterval","g","filter","map","i","key","style","Main","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.8869937a.chunk.js","sourcesContent":["import { css } from 'styled-components';\r\n\r\nexport const themeGet = (...args) => props => {\r\n  let current = props.theme;\r\n  for (const arg of args) {\r\n    if (!current[arg]) {\r\n      console.error('[Theming] Could not find', arg, 'in', current);\r\n      return '';\r\n    }\r\n    current = current[arg];\r\n  }\r\n  return current;\r\n};\r\n\r\n\r\n/* MIXINS */\r\nexport const mixin_clearBubble = () => {\r\n  return css`\r\n    border: .2rem solid rgba(255, 255, 255, 0.2);\r\n    border-color: rgba(255, 255, 255, 0.2) rgba(0, 0, 0, 0.2) rgba(0, 0, 0, 0.2) rgba(255, 255, 255, 0.2);\r\n    border-radius: 1rem;\r\n    box-shadow: .1rem .1rem .5rem black;\r\n  `;\r\n}\r\n\r\nexport const mixin_textStroke = (thickness, spread, color) => {\r\n  return css`\r\n    text-shadow:  -${thickness} -${thickness} ${spread} ${color},\r\n                  ${thickness} -${thickness} ${spread} ${color},\r\n                  -${thickness} ${thickness} ${spread} ${color},\r\n                  ${thickness} ${thickness} ${spread} ${color},\r\n                  -${thickness} -${thickness} ${spread} ${color},\r\n                  ${thickness} -${thickness} ${spread} ${color},\r\n                  -${thickness} ${thickness} ${spread} ${color},\r\n                  ${thickness} ${thickness} ${spread} ${color},\r\n                  -${thickness} -${thickness} ${spread} ${color},\r\n                  ${thickness} -${thickness} ${spread} ${color},\r\n                  -${thickness} ${thickness} ${spread} ${color},\r\n                  ${thickness} ${thickness} ${spread} ${color},\r\n                  -${thickness} -${thickness} ${spread} ${color},\r\n                  ${thickness} -${thickness} ${spread} ${color},\r\n                  -${thickness} ${thickness} ${spread} ${color},\r\n                  ${thickness} ${thickness} ${spread} ${color};\r\n  `;\r\n}\r\n\r\n\r\n/* COLORS */\r\nexport const listColors = () => {\r\n  return Object.keys(store.color);\r\n}\r\n\r\nexport const getColor = (colorId) => {\r\n  return store.color[colorId];\r\n}\r\n\r\n/* from pablo on https://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors */\r\nexport const shadeColor = (colId, percent) => {\r\n  var color = store.color[colId] || colId;\r\n\r\n  var R = parseInt(color.substring(1,3),16);\r\n  var G = parseInt(color.substring(3,5),16);\r\n  var B = parseInt(color.substring(5,7),16);\r\n\r\n  R = parseInt(R * (100 + percent) / 100);\r\n  G = parseInt(G * (100 + percent) / 100);\r\n  B = parseInt(B * (100 + percent) / 100);\r\n\r\n  R = (R<255)?R:255;  \r\n  G = (G<255)?G:255;  \r\n  B = (B<255)?B:255;  \r\n\r\n  var RR = ((R.toString(16).length===1)?\"0\"+R.toString(16):R.toString(16));\r\n  var GG = ((G.toString(16).length===1)?\"0\"+G.toString(16):G.toString(16));\r\n  var BB = ((B.toString(16).length===1)?\"0\"+B.toString(16):B.toString(16));\r\n\r\n  return \"#\"+RR+GG+BB;\r\n}\r\n\r\n/* BREAKPOINTS */\r\n/* https://jsramblings.com/how-to-use-media-queries-with-styled-components/ */\r\nconst breakpoints = {\r\n  mobile_tiny: '300px',\r\n  mobile_medium: '400px',\r\n  mobile_large: '500px',\r\n  tablet: '768px',\r\n  desktop: '1024px'\r\n}\r\n\r\nexport const getBreakpoint = {\r\n  mobile_tiny: `(min-width: ${breakpoints.mobile_tiny})`,\r\n  mobile_medium: `(min-width: ${breakpoints.mobile_medium})`,\r\n  mobile_large: `(min-width: ${breakpoints.mobile_large})`,\r\n  tablet: `(min-width: ${breakpoints.tablet})`,\r\n  desktop: `(min-width: ${breakpoints.desktop})`\r\n};\r\n\r\nconst store = {\r\n  color:{\r\n    black: '#000000',\r\n    grey: '#373737',\r\n    grey_light: '#A39F8E',\r\n    white: '#fef8dd',\r\n    blue: '#1fb9f3',\r\n    green: '#51f249',\r\n    yellow: '#fff249',\r\n    red: '#F55658',\r\n    purple: '#6b1ff3'\r\n  },\r\n  shadow:{\r\n    z1: '-0.1rem 0.1rem .25rem .1rem rgba(0,0,0,0.16)',\r\n    z2: '-0.1rem 0.1rem .25rem .1rem rgba(0,0,0,0.36)',\r\n    z3: '-.2rem .5rem 1rem .2rem rgba(0,0,0,.36)'\r\n  },\r\n  value:{\r\n    headerHeight: '7.5rem',\r\n    menuWidth: '12rem'\r\n  },\r\n  mixins:{},\r\n  breakpoints:{\r\n    mobile_tiny: '300px',\r\n    mobile_medium: '400px',\r\n    mobile_large: '500px',\r\n    tablet: '768px',\r\n    desktop: '1024px'\r\n  }\r\n}\r\n\r\nexport default store;\r\n","import React, { useState } from 'react';\r\nimport styled, { css } from 'styled-components';\r\nimport { getColor } from '../../themes';\r\nimport { useWindowSize, useInterval } from '../utils';\r\n\r\nconst alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' '];\r\nconst gridCols = 20;\r\nconst gridRows = 10;\r\n\r\nconst SECRET_PHRASE = 'some secret words';\r\n\r\nconst S = {};\r\nS.WordBox = styled.div`\r\n  position:absolute;\r\n  left:10%;\r\n  top:10%;\r\n  width:80%;\r\n  height:80%;\r\n  border-radius:5rem;\r\n  border:1rem solid ${getColor('blue')};\r\n  background-color:black;\r\n\r\n  padding:2rem;\r\n\r\n  ul{\r\n    width:100%;\r\n    height:100%;\r\n    position:relative;\r\n    margin:0;\r\n    font-size:3rem;\r\n\r\n    li{\r\n      list-style:none;\r\n    }\r\n  }\r\n`;\r\n\r\nS.Letter = styled.li`\r\n  position:absolute;\r\n  color:${getColor('grey')};\r\n\r\n  ${p => p.isSecret && css`\r\n    color: ${getColor('green')};\r\n  `}\r\n`;\r\n\r\nconst randoLetterPlease = () => {\r\n  return alphabet[Math.floor(Math.random() * alphabet.length)];\r\n};\r\n\r\nconst getIdxFromColRow = (col, row) => {\r\n  return (row * gridCols) + col;\r\n}\r\n\r\nconst getSecretIndicies = (secretWord, rows, cols) => {\r\n  const startRow = Math.floor(rows / 2);\r\n  if(secretWord.length > cols) throw `SECRET WORD IS TOO LONG WHAT HAVE YOU DONE!?!?! IT MUST BE NO MORE THAN ${gridCols} CHARACTERS`;\r\n\r\n  const startCol = Math.floor((cols - secretWord.length) / 2);\r\n  \r\n  const secret = [];\r\n  for(let c = 0; c < secretWord.length; c++){\r\n    secret.push({\r\n      gridIdx: getIdxFromColRow(startCol + c, startRow),\r\n      rIdx: startRow,\r\n      cIdx: startCol + c,\r\n      text: secretWord[c]\r\n    });\r\n  };\r\n\r\n  return secret;\r\n}\r\n\r\nconst makeGrid = (cols, rows, foundSecrets) => {\r\n  const newGrid = [];\r\n  const wb = document.querySelector('#wordbox ul');\r\n  if(!wb) return [];\r\n\r\n  const dims = {\r\n    width: wb.clientWidth,\r\n    height: wb.clientHeight\r\n  };\r\n\r\n  const xStep = dims.width / cols;\r\n  const yStep = dims.height / rows;\r\n  const xStart = 0;\r\n  const yStart = 0;\r\n\r\n  const secretStuff = getSecretIndicies(SECRET_PHRASE, gridRows, gridCols);\r\n\r\n  let yPos = 0;\r\n  for(let r = 0; r < rows; r++){\r\n    yPos = yStart + r * yStep;\r\n    for(let c = 0; c < cols; c++){\r\n      // predict idx, why not\r\n      const gridIdx = newGrid.length - 1;\r\n      let didFindSecret = false;\r\n      // assign the letter\r\n      let letter;\r\n      const existingSecret = foundSecrets.find(s => s.gridIdx === gridIdx);\r\n      if(!!existingSecret){\r\n        letter = existingSecret.text;\r\n        didFindSecret = true;\r\n      }else{\r\n        //get a new one!\r\n        letter = randoLetterPlease();\r\n        const randomSecretPick = secretStuff.find(s => s.gridIdx === gridIdx);\r\n        if(!!randomSecretPick && (randomSecretPick.text === letter)){\r\n          didFindSecret = true;\r\n        }\r\n      }\r\n\r\n      newGrid.push({\r\n        gridIdx,\r\n        x: xStart + c * xStep,\r\n        y: yPos,\r\n        text: letter,\r\n        didFindSecret\r\n      });\r\n    }\r\n  }\r\n\r\n  return newGrid;\r\n};\r\n\r\nfunction WordBox() {\r\n  let [count, setCount] = useState(0);\r\n  let [delay, setDelay] = useState(75);\r\n  let [grid, setGrid] = useState([]);\r\n  let [foundSecrets, setFoundSecrets] = useState([]);\r\n  useWindowSize();\r\n\r\n  useInterval(() => {\r\n    // Your custom logic here\r\n    const g = makeGrid(gridCols, gridRows, foundSecrets);\r\n    setGrid(g);\r\n    setFoundSecrets(g.filter(c => c.didFindSecret));\r\n    setCount(count + 1);\r\n  }, delay, foundSecrets);\r\n\r\n  return (\r\n    <S.WordBox id=\"wordbox\">\r\n      <ul>\r\n        {grid.map((letter, i) => \r\n          <S.Letter key={i} isSecret={letter.didFindSecret} style={{ 'left': `${letter.x}px`, 'top': `${letter.y}px` }}>\r\n            <span>\r\n              {letter.text}\r\n            </span>\r\n          </S.Letter>\r\n        )}\r\n      </ul>\r\n    </S.WordBox>\r\n  );\r\n}\r\n\r\nexport default WordBox;\r\n","import React, { useState, useEffect, useRef } from 'react';\r\n\r\n/*\r\n  Thanks useHooks! https://usehooks.com/useWindowSize/\r\n*/\r\n// Hook\r\nexport function useWindowSize() {\r\n  // Initialize state with undefined width/height so server and client renders match\r\n  // Learn more here: https://joshwcomeau.com/react/the-perils-of-rehydration/\r\n  const [windowSize, setWindowSize] = useState({\r\n    width: undefined,\r\n    height: undefined,\r\n  });\r\n  useEffect(() => {\r\n    // Handler to call on window resize\r\n    function handleResize() {\r\n      // Set window width/height to state\r\n      setWindowSize({\r\n        width: window.innerWidth,\r\n        height: window.innerHeight,\r\n      });\r\n    }\r\n    // Add event listener\r\n    window.addEventListener(`resize`, handleResize);\r\n    // Call handler right away so state gets updated with initial window size\r\n    handleResize();\r\n    // Remove event listener on cleanup\r\n    return () => window.removeEventListener(`resize`, handleResize);\r\n  }, []); // Empty array ensures that effect is only run on mount\r\n  return windowSize;\r\n}\r\n\r\n\r\n\r\n/*\r\nThanks overracted!\r\nhttps://overreacted.io/making-setinterval-declarative-with-react-hooks/\r\n*/\r\nexport function useInterval(callback, delay) {\r\n  const savedCallback = useRef();\r\n\r\n  // Remember the latest callback.\r\n  useEffect(() => {\r\n    savedCallback.current = callback;\r\n  }, [callback]);\r\n\r\n  // Set up the interval.\r\n  useEffect(() => {\r\n    function tick() {\r\n      savedCallback.current();\r\n    }\r\n    if (delay !== null) {\r\n      let id = setInterval(tick, delay);\r\n      return () => clearInterval(id);\r\n    }\r\n  }, [delay]);\r\n}","import React from 'react';\r\nimport WordBox from './wordbox';\r\n\r\nfunction Main() {\r\n  return (\r\n    <div>\r\n      <WordBox />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Main;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './themes/theme.scss';\r\nimport Main from './containers/main';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<Main />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}